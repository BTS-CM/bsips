    BSIP: 0069
    Title: Additional Assert Predicates
    Authors: Christopher J. Sanborn, ...
    Status: Draft
    Type: Protocol
    Created: 2019-06-08
    Discussion: https://github.com/bitshares/bsips/issues/175

# Abstract

New predicates for the `assert_operation` are proposed to enable conditional validity of transactions for various use cases, including safety of transactions that depend on recent prior transactions, safety of transactions signed by hardware wallets, and transactions signed in advance but intended to be broadcast at a later time.

# Motivation

This BSIP is motivated by a multitude of potential use cases in which conditional validity of a transaction may be valuable.  One example is the implementation of payment channels described in [Short-lived Unidirectional Payment Channels](bsip-0063.md), which depends on refund transactions being secured by a time lock.  A time lock could be trivially implemented as an assert on a particular head block time.  Thus an assert predicate `head_block_time_ge_time_predicate` could open up new possible applications on top of the BitShares protocol.

There are other interesting use cases and the predicates that would support them.  So this BSIP will serve as a batch list of desired predicates to add in an upcoming scheduled protocol upgrade.

# Rationale

The `assert_operation` as currently implemented offers only three predicates, which are primarily geared at ensuring that a newly created account or asset has in fact been created as believed before doing something with that account or asset that could produce unintended consequences were the account or asset _not_ created as believed. (This protects against, e.g., a race condition in which a block reorganization could potentially change the user ID given to a newly-registered user name.) The three existing predicates are defined in [`assert.hpp`](https://github.com/bitshares/bitshares-core/blob/e3d1226e30cbd1e2b081642ad04aa7e2f27ac1af/libraries/chain/include/graphene/chain/protocol/assert.hpp) as:

| Predicate | Description |
|:----------|:------------|
| `account_name_eq_lit_predicate` | Tests the name of a given account ID equals a particular string literal |
| `asset_symbol_eq_lit_predicate` | Tests the symbol of a given asset ID equals a particular string literal |
| `block_id_predicate`            | Tests that a block with a given ID appears within the last 2^16 blocks |

The additional predicates proposed are described in the following subsections.

## Head block time and head block height predicates

Propose to add the following predicates, which support applications such as payment channels:

| Predicate | Description |
|:----------|:------------|
| `head_block_time_ge_time_predicate` | Head block time meets or exceeds `time`. Ensures a transaction is only valid at or after a specified time. |
| `head_block_time_lt_time_predicate` | Head block time is less than `time`. Ensures a transaction is only valid if included _before_ a specified time. |
| `head_block_height_ge_height_predicate` | Head block height meets or exceeds `height`. Ensures a transaction is only valid at or after a specified block height. |
| `head_block_height_lt_height_predicate` | Head block height is less than `height`. Ensures a transaction is only valid if included _before_ a specified block height. |

_TODO: Should the predicates include ALL the comparisons: eq, lt, le, gt, ge?  OR is ge, lt sufficient for real-world use cases? Note also that block_time_lt_time might be functionally equivalent to a transaction expiration and redundant._

## Account and Asset Creation Safety

The existing predicates check for the successful creation of a new account or asset by testing the correlation of an object ID and a name string.  But this still leaves open a vulnerability from an attacking party trying to register the same account name or asset symbol.  Thus to confirm expected object creation, it would be better to test the account authorities or asset issuer, than to check the name or symbol.

Propose to add the following predicates:

| Predicate | Description |
|:----------|:------------|
| `account_owner_is_authority_predicate` | Tests owner authority |
| `account_active_is_authority_predicate` | Tests active authority |
| `asset_issuer_is_account_predicate` | Tests asset issuer |

## Predicates Useful to Hardware Wallets

The existing predicates `account_name_eq_lit_predicate` and `asset_symbol_eq_lit_predicate` are useful to hardware wallets which must sign transactions that make reference to object IDs, but would like to present details to the user for confirmation using user-friendly object names or symbols.  The hardware wallet cannot verify that chain state maps a particular object to a particular string.  However, it _can_ protect the user by only signing transactions which are inherently invalid if the expected mapping is not truthful.  Thus these assert predicates can allow the wallet to display, e.g., a transfer operation using account name instead of account ID.  Similarly for asset symbols.

For assets, however, there is one additional field which the wallet would want to assert, for which there is not yet an existing predicate.  This is the asset precision field.  Thus we propose to add the following predicate:

| Predicate | Description |
|:----------|:------------|
| `asset_precision_predicate` | Checks precision field of an asset |


# Specifications

_Specific behavior of each predicate to be detailed here._

# Discussion
# Summary for Shareholders
# Copyright
# See Also
